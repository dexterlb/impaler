#lang racket

; ***************************************************
; * PART 1: simple recursion
; ***************************************************

; so we have `let`, allowing us to do things like this:
(define example-01-let
  (let ((foo 42)
        (bar 26))
    (+ foo bar)))    ; --> 68

; we also have `let*`, allowing us to do things like this:
(define example-02-let*
  (let* ((foo 42)
         (bar (+ foo 1)))
    (- bar foo)))    ; --> 1

; and the even more powerful `letrec`, allowing us to do things like this
(define example-03-letrec-fact
  (letrec
      ((fact (lambda (x) (if (< x 1)
                             1
                             (* x (fact (- x 1)))))))
    (fact 5)))   ; --> 120

; and even things like this
(define example-04-even-odd
  (letrec
       ((is-even? (lambda (x) (if (= x 0) #t (is-odd?  (- x 1)))))
        (is-odd?  (lambda (x) (if (= x 0) #f (is-even? (- x 1))))))
     (is-even? 42)))    ; --> #t

; essentially, `letrec` has a similar interface to `let*`, but
; lets us use recursion: we can use the name being defined
; inside the same body that we're defining

; so, `letrec` is a builtin form in Scheme and it lets us do recursion.
; there are also other ways to do recursion in Scheme: for example,
; `define` allows us to use all names, even ones that depend on the current
; body being defined.

; imagine, however, that our Scheme supports no recursion and we must
; define it ourselves. This is infact possible, with the "fixed point"
; combinator, or "Y combinator":

(define fix
  (lambda (f)
    (f (lambda (x) ((fix f) x)))))

; we can now define a version of `fact` that uses `fix` instead of
; making use of a recursion mechanism that is already available
; in Scheme:

(define example-05-fix-fact
  (let ((fact (fix
               (lambda (f)
                 (lambda (x) (if (< x 1)
                                 1
                                 (* x (f (- x 1)))))))))
    (fact 5)))    ; --> 120

; armed with this knowledge, we can build a function
; that transforms code containing `letrec` into code that
; uses no letrec and uses the `fix` combinator instead.
; Of course, this will only work for `letrec`'s with
; a single definition - we don't know how to do
; multiple recursion yet!

; first, we'll implement a function that generates code
; equivalent to a single letrec:

(define (build-letrec-single defs body)
  (let*
      ((args (map car defs))
       (arg-bodies (map transform-body-single defs)))

    (cons (list 'lambda args body) arg-bodies)))

(define (transform-body-single def)
  (let*
      ((name (car def))
       (body (cadr def)))
    (list 'fix (list 'lambda (list name) body))))

; we can use this function to generate code that computes `fact`:

(define example-06-letrec-single-fact-ast
  (build-letrec-single
   '((fact (lambda (x) (if (= x 0) 1 (* x (fact (- x 1)))))))
   '(fact 5)))
; now, (eval example-06-letrec-single-fact-ast) gives 120.
; notice that we *quoted* the arguments to `build-letrec-single`,
; since we want to transform the *code* instead of passing the result
; of evaluating the code to our function

; note, however, that the code generated by `build-letrec-single`
; requires `fix` to be defined. It is, however, trivial to include
; the definition of `fix` in the result.

; we can now easily build  a transformer that changes all occurances
; of `letrec` in given code to equivalent letrec-less code:
(define (transform-letrecs-single ast)
  (if (pair? ast)
      (if (equal? (car ast) 'letrec)
          (build-letrec-single (cadr ast) (caddr ast))
          (map transform-letrecs-single ast))
      ast))

(define example-07-letrec-single-fact-ast2
  (transform-letrecs-single
   '(letrec
      ((fact (lambda (x) (if (= x 0) 1 (* x (fact (- x 1)))))))
    (fact 5))))

; now, executing `(eval example-07-letrec-single-fact-ast2)` gives 120.

; ***************************************************
; * PART 2: mutual recursion
; ***************************************************

; we can now move on to building a more powerful version of this transformer
; that can implement mutual recursion. For this, we need the
; polyvariadic fixed point combinator, or "Y* combinator".

(define (polyfix . l)
  ((lambda (x) (x x))
   (lambda (p)
     (map (lambda (li) (lambda x (apply (apply li (p p)) x))) l))))

; what `polyfix` does is similar to `fix`, but takes a *list* of
; functions (f1 f2 ... fn) and finds the fixed point of
; F(l) = f1(l_1 l_2 ... l_n), which is itself a list of functions

; we can now construct `build-letrec-poly` - a function that
; builds code equivalent to a `letrec` with multiple definitions,
; allowing for mutual recursion.
(define (build-letrec-poly defs body)
  (let*
      ((args (map car defs))
       (item-bodies (map cadr defs))
       (arg-bodies (map (lambda (def-body) (list 'lambda args def-body)) item-bodies))
       (flist (gensym "flist"))    ; since we're making a "new" variable for the lambda
                                   ; argument, we use a fresh symbol
       (arg-getters (generate-element-getters flist args))
       (result-body (cons (list 'lambda args body) arg-getters)))

    (list (list 'lambda (list flist) result-body) (cons 'polyfix2 arg-bodies))))

; helper function that generates a list of accessors for all elements in
; the given list
(define (generate-element-getters list-name l)
  (if (null? l)
      (list)
      (cons (list 'car list-name)
            (map (lambda (subl) (list (car subl) (cons 'cdr (cdr subl))))
                 (generate-element-getters list-name (cdr l))))))

; and now we define `transform-letrecs-poly`, which is the
; polyvariadic version of `transform-letrecs-single` and
; emulates the builtin letrec

(define (transform-letrecs-poly ast)
  (if (pair? ast)
      (if (equal? (car ast) 'letrec)
          (build-letrec-poly (cadr ast) (caddr ast))
          (map transform-letrecs-poly ast))
      ast))

(define example-08-letrec-poly-even-odd
  (transform-letrecs-poly
   '(letrec
        ((is-even? (lambda (x) (if (= x 0) #t (is-odd?  (- x 1)))))
         (is-odd?  (lambda (x) (if (= x 0) #f (is-even? (- x 1))))))
      (is-even? 42))))

; --> '((lambda (flist845276)
;         ((lambda (is-even? is-odd?) (is-even? 42)) (car flist845276) (car (cdr flist845276))))
;       (polyfix
;        (lambda (is-even? is-odd?) (lambda (x) (if (= x 0) #t (is-odd? (- x 1)))))
;        (lambda (is-even? is-odd?) (lambda (x) (if (= x 0) #f (is-even? (- x 1)))))))

; so now, if we do `(eval example-08-letrec-poly-even-odd)`, we get #t as expected.


; we have now successfully built a transformer with the abillity to convert
; letrec-ridden code to code that contains no recursion!



; ***************************************************
; * PART 3: mutual recursion, take two
; ***************************************************

; still, `polyfix` seems a bit dirty (it uses functions like `map` and `apply`,
; which use recursion themselves). We shall now embark on a quest to rid ourselves
; of all such heresy, lest only the purest form of `fix` remain in the code we generate.

; in order to use the single version of fix for multiple recursion, we will have to emulate something like this:
(define example-09-even-odd-fix
  '((lambda (even-odd)
      ((lambda (is-even? is-odd?) (is-even? 42)) (even-odd car) (even-odd cadr)))
    (fix
     (lambda (even-odd)
       (lambda (accessor)
         (accessor (list ; we need to delay the evaluation of this list so that it doesn't go into infinite loop
                      ((lambda (is-even? is-odd?) (lambda (x) (if (= x 0) #t (is-odd? (- x 1))))) (even-odd car) (even-odd cadr))
                      ((lambda (is-even? is-odd?) (lambda (x) (if (= x 0) #f (is-even? (- x 1))))) (even-odd car) (even-odd cadr)))))))))

; however, the example above will not work due to insufficient laziness: we need `even-odd` to
; be called *after* x is known, not before. However, everyone knows that
; the universal solution to any problem is simply adding an extra level of indirection:
(define example-10-even-odd-fix2
  '((lambda (even-odd)
      ((lambda (is-even? is-odd?) (is-even? 43))
       (lambda (x) ((even-odd car) x))
       (lambda (x) ((even-odd cadr) x))))
    (fix
     (lambda (even-odd)
       (lambda (accessor)
         (accessor (list ; we need to delay the evaluation of this list so that it doesn't go into infinite loop
                      ((lambda (is-even? is-odd?) (lambda (x) (if (= x 0) #t (is-odd? (- x 1)))))
                       (lambda (x) ((even-odd car) x))
                       (lambda (x) ((even-odd cadr) x)))
                      ((lambda (is-even? is-odd?) (lambda (x) (if (= x 0) #f (is-even? (- x 1)))))
                       (lambda (x) ((even-odd car) x))
                       (lambda (x) ((even-odd cadr) x))))))))))
; calling (eval example-10-even-odd-fix2) correctly gives `#f`.

(define example-11-even-odd-fix3
  '((lambda (even-odd)
      ((lambda (is-even? is-odd?) (is-even? 43))
       (lambda args (apply (even-odd car) args))
       (lambda args (apply (even-odd cadr) args))))
    (fix
     (lambda (even-odd)
       (lambda (accessor)
         (accessor (list ; we need to delay the evaluation of this list so that it doesn't go into infinite loop
                      ((lambda (is-even? is-odd?) (lambda args (if (= x 0) #t (is-odd? (- x 1)))))
                       (lambda args (apply (even-odd car) args))
                       (lambda args (apply (even-odd cadr) args)))
                      ((lambda (is-even? is-odd?) (lambda args (if (= x 0) #f (is-even? (- x 1)))))
                       (lambda args (apply (even-odd car) args))
                       (lambda args (apply (even-odd cadr) args))))))))))

; now, let's try to make a version of `transform-letrecs-poly` that generates code like in
; the example above - starting with `build-letrec poly`:
(define (build-letrec-poly2 defs body)
  (let*
      ((args (map car defs))
       (item-bodies (map cadr defs))
       (arg-bodies (map (lambda (def-body) (list 'lambda args def-body)) item-bodies))
       (f (gensym "f"))
       (arg-getters
        (map (lambda (getter body) (lambdify getter body f))
        (generate-partial-element-getters args) item-bodies))
       (result-body (cons (list 'lambda args body) arg-getters))
       (rec-body 'baba))

    (list (list 'lambda (list f) result-body) (cons 'fix rec-body))))

(define (lambdify getter body f)
  (if (equal? (car body) 'lambda)
      (list 'lambda (cadr body) (cons (list f getter) (cadr body)))
      (list f getter)))

(define (generate-partial-element-getters args)
  (let*
      ((flist (gensym "flist"))
       (partialise
        (lambda (getter)
          (list 'lambda (list flist) getter))))
    (map partialise (generate-element-getters flist args))))
             
; now `transform-letrecs-poly2` is absolutely analogous to `transform-letrecs-poly`
(define (transform-letrecs-poly2 ast)
  (if (pair? ast)
      (if (equal? (car ast) 'letrec)
          (build-letrec-poly2 (cadr ast) (caddr ast))
          (map transform-letrecs-poly2 ast))
      ast))

(define example-11-letrec-poly2-even-odd
  (transform-letrecs-poly2
   '(letrec
        ((is-even? (lambda (x) (if (= x 0) #t (is-odd?  (- x 1)))))
         (is-odd?  (lambda (x) (if (= x 0) #f (is-even? (- x 1))))))
      (is-even? 42))))
