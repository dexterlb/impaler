\documentclass[main.tex]{subfiles}
\begin{document}

I want to build a programming language with the following properties:
\begin{enumerate}
    \item very small and simple
    \item powerful metaprogramming using lisp-like macros
    \item completely immutable
    \item performant
    \item \emph{compiled} (as much as this term may apply to lisp-like languages)
\end{enumerate}

The main technique I wish to leverage is \emph{partial evaluation}, which is
inevitably used in any sufficiently mature implementation of a programming
language compiler/interpreter, but usually not as a first-class concept

\reword{I want to do the following things which would normally be slow} and
leverage partial evaluation to attempt to make performance on-par with
\reword{SOTA} solutions:
\begin{itemize}
    \item full immutability
    \item runtime function specialisation (or maybe not, this might not be feasible)
    \item reference-counted garbage collection
\end{itemize}

Most languages in the wild [citation needed] are either \ref{fixme, simple} or
\ref{fixme, performant}. This can be addressed with partial evaluation.

Also, most languages [citation needed, erlang] are either immutable or performant.
This can be addressed by using persistent data structures.



\greenbox{

\textbf{BULLSHIT ALERT! The assumptions in this paragraph are stupid,
    uninformed and outright wrong! Do your fact-checking, past me!}

In lisp-like languages, there are usually two phases: first we execute macros,
then we execute code. With compiled lisp-like languages, macro evaluation is
usually done during compilation. This creates problems - for example, using
`runtime' code inside macros is usually not straight-forward.  I wish to
implement a small lisp-like language to see if these two stages can be merged
by having macros be simply functions with slightly different semantics -
essentially, performed during runtime, from the perspective of the programmer.
}

This document is an informal description of the language. The examples will
have generic `lispy' pseudocode notation.

The language features could be defined in several tiers:
\begin{itemize}
    \item Tier 0 (\emph{proof of concept})
    \item Tier 1 (\emph{toy language})
    \item Tier 2 (\emph{practically usable})
\end{itemize}

\subsection{Proposed proof of concept language (Tier 0)}

Here we'll specify a programming language.

Semantically, our language shall have the following classes of internal values:
\begin{enumerate}
    \item symbols
    \item lists
    \item opaque external values
    \item function objects
\end{enumerate}

The only classes of internal values that may be expressed syntactically are
symbols and lists\footnote{%
    It would be quite beneficial for our language to
    support other atoms apart from symbols, namely numbers and strings.
    However, for a proof of concept they are not needed: consider that numbers
    and chars are simply symbols, while strings are lists of chars.}.
External values and function objects are created by the interpreter/compiler as
results of evaluating complex expressions.

Semantics shall be defined as such:

\begin{itemize}
    \item abstraction: \code{(lambda (\(a_1 a2 ... a_n\)) \(P\))} - evaluates to
        a function object which carries the current scope (environment)
    \item application: \code{(f \(S_1 S_2 ... S_n\))} - evaluates the function
        object associated with the symbol \code{f} in the current scope,
        using the results from evaluating \(S_1, S_2, ..., S_n\) as arguments.
    \item quote: \code{(quote \(S_1 S_2 ... S_n\))} - evaluates to the literal
        list \code{(\(S_1 S_2 ... S_n\))}
    \item expansion: \code{(expand \(S\))} - syntactically replace this expression
        with the result from evaluating \(S\), and then evaluate it
\end{itemize}

\subsection{Garbage collection}
foo

\subsection{Partial evaluation}

In this context, we regard \emph{partial evaluation} to be ...

\begin{lstwrap}\begin{lstlisting}[language=lisp]
(here is some code)
\end{lstlisting}\end{lstwrap}

\begin{mexample}
    this shall be an example
    \begin{lstwrap}\begin{lstlisting}[language=lisp]
    (here is some code inside the example)
    \end{lstlisting}\end{lstwrap}
\end{mexample}

\subsection{to be continued}
still unfinished \pika

\end{document}
